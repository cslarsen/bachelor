\chapter{Design}
\label{chapter:design}

Now that we have discussed the main algorithms and our simplification of
them, we must take a look at what OpenFlow can offer us to reach our goals.

\input{openflow-versions}

\section{Limitations in OpenFlow}

By looking at what OpeFlow versions 1.1--1.3 offer, one can see that we can't really
make use of any of the added functionality for running Paxos.  What we need
is the ability to run programs on the switch, which is something OpenFlow
does not support at all.  Neither do their action primitives add up to
anything that could be used for remembering state (such as the current round
number) or executing if-then-else statements.

One possibly solution would be to insert a lot of flow table entries that
each waited for a specific round number.  But that would not be an elegant
or practical solution.

They \textit{do}, however, offer us the ability to implement Paxos entirely
on the controller.  We have actually done this, but one of the stated goals
of this thesis was to move parts of the Paxos code down to the switch
itself.  For this we simply need to be able to run full Turing-equivalent
programming languages.

For remembering state, we looked at the metadata that is available in later
versions of OpenFlow.  However, metadata only exists as the packet is
processed in the pipeline of flow tables, and is erased when the packet
actions are applied at the end.  To remember state, we will need to add a
table to hold such data in the switch.

Finally, we have to look at which OpenFlow versions our software components
support.

Mininet seems to support whatever version of OpenFlow that Open vSwitch uses,
as this is what it uses as a switch.  Open vSwitch\index{Open vSwitch}
supports OpenFlow versions 1.0---1.3 almost fully, but support for 1.4 is
flaky, and may crash.  So 1.4
is out of the question.

The most obvious component to look at is POX, our controller framework in
Python, which only supports OpenFlow 1.0.\footnote{It does seem to support
some \textit{Nicira extensions}\index{Nicira}, though.  These are
extensions that were originally added to early OpenFlow versions, but
much of it has been implemented in later versions.  There is also a fork
of POX (and other software projects) written by CPqD that adds support
for newer OpenFlow versions, but we haven't looked at it.}

But the major point for our decision is what OpenFlow can offer us.
There simply is no way of executing general code, and there is no way to
remember state.\footnote{We even investigated whether we could use the
counters to count round numbers or store them in IPv6 addresses, using VLAN
for storing data, etc.  All those ideas turned out to be very hairy to
implement, with a real possibility of not working correctly.}

All in all, we have decided to use OpenFlow 1.0 where applicable and extend
it where needed.  Using the flow table, controller and bytecode is a simple
but good, practical decision.

\section{Decisions}

We have seen that OpenFlow does not offer the capabilities we need to
implement Paxos on the switch.  We could implement Paxos on the controller,
but that would be nearly equivalent to having adding Paxos to the software
running on the end-hosts.

Thus, we have decided to use a combination of OpenFlow flow table rules and
programs running in Open vSwitch as bytecode\index{bytecode} compiled
fragments to handle the details of the Paxos algorithms.

\todo{Legg til selve designet her, siden tittelen sier det! Vis hvor vi
bruker flow tables (ikke vis detaljer, det kommer senere), vis
nettverksflyt, vis hvor bytecode blir eksekvert, og hva som kjører på
controller.}

\section{Choice of switch programming language}

\todo{Insert a "defense" of why we chose Forth, and why we didn't implement
everything in OpenFlow}

What we want is to provide \textit{simple} primitives that can be
implemented to run custom code \textit{efficiently} on the
hardware---requiring little memory and few cycles per operation---while
still being useful for other networking protocols.
\todo{back up this statement on the last part}

We think this is a good implementation for fastidious hardware implementors,
but \textit{any} programming language---preferably one that can produce
bytecode---would work just as fine.
\todo{Finn ut hvor jeg snakker om Ngaro og flytt tekst over her.}

