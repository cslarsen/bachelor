\section{An L2 Learning Switch in OpenFlow}
\label{chapter:l2.learning.switch}

When you write an OpenFlow controller, the flow table is empty and all
packets will by default be delivered to the controller via an
\textit{upcall}\index{upcall}.

The controller must then decide what to do with the packets.  If we don't
implement any sort of forwarding behaviour for the packets, none of the
hosts will be able to communicate.

So our system will need a forwarding mechanism at the bottom of the Paxos
networking capabilities.  The simplest system is just to implement a
\textit{hub}\index{hub}:  For each packet coming in to the switch, flood it
(or, \textit{rebroadcast}\index{rebroadcasting}) to all ports, and let each
connected host decide to receive packets meant for them (algorithm
\ref{algorithm:l2.hub}).

\begin{algorithm}
  \begin{algorithmic}
    \On{Ethernet frame $e$}{port $p$}
      \State \textbf{flood} $e$ \Comment{Send packet out on \textit{all} ports}
    \EndOn
  \end{algorithmic}
  \caption{An L2 hub algorithm}
  \label{algorithm:l2.hub}
\end{algorithm}

A slightly better approach is to implement an \ac{L2} learning
switch\index{switch!L2 learning}.
The difference from the flood-to-all hub above is that we create a table
that maps MAC-addresses to ports and then forward each packet to a single
port.  We then achieve less traffic on the network.

As we build up this table we could also install flow table entries so that the
switch will be able to forward packets by itself.  This is indicated in
algorithm \vref{algorithm:l2.learning.switch} with
\textbf{add.flowtable.entry}, but is an optional step.

\begin{algorithm}
  \begin{algorithmic}
    \State $M \gets \emptyset$\Comment{Set of $\langle address,\ port \rangle$-tuples}
    \State
    \On{Ethernet frame $e$}{port $p$}
      \State $M \gets M \cup \langle e_{src},\ p \rangle$ \Comment{Learn
        port $p$ for $e_{src}$ (source MAC-address)}
      \State
      \State \textbf{add OpenFlow rule }(for Ethernet frames from $e_{dst}$ to
        $e_{src}$, forward to port $p$)
      \State
      \If{$\{ \exists q : \langle e_{dst},\ q \rangle \in M \}$}
        \Comment{See if we know the destination port $q$}
        \State \textbf{forward} $e$ \textbf{to} port $q$ for $e_{dst}$ in $M$
      \Else
        \State \textbf{flood} $e$ \Comment{Act as hub; rebroadcast packet
          $e$ to all ports}
      \EndIf
    \EndOn
  \end{algorithmic}
  \caption{An L2 learning switch algorithm for an OpenFlow controller}
  \label{algorithm:l2.learning.switch}
\end{algorithm}
\todo{Fiks membership test sjekk her, skal en feks bruke $\exists$ eller noe
  sånt, og er wildcard-operator bruk korrekt?}

As you can see, algorithm \ref{algorithm:l2.learning.switch} will need to
run at least twice before it will know both the source and destination ports
for two MAC-addresses.  If we send an \textit{\acs{ICMP} ping
packet}\index{ping} from host $a$ to $b$, the switch running the algorithm
will first learn which port $a$ is on, and then flood the packet out all
ports (it doesn't know which port $b$ is on, yet).

$b$ will then receive the packet\footnote{The other hosts' networking stack
will simply drop the packet, as it's not for them---unless their \ac{NIC}
is running in \textit{promiscuous mode}\index{promiscuous mode}, capturing
all packets.} and send an \acs{ICMP} ping reply packet.  When this
reaches the switch, it will learn which port $b$ is on and is now able
to do a packet forwarding instead of a flood, because it knows which
port $a$ is on (the packet from $b$ has $b_{address}$ as source
MAC-address and $a_{address}$ as destination MAC-address).

We can also install rules in the OpenFlow flow table so that
subsequent packets to these two hosts will be forwarded automatically in the
forwarding plane by the switch.  An optimization to the above algorithm
would be to install two flows:  One as shown above, and one with the source
and destination addresses reversed, with the correct port number.

Our algorithm is a well-known implementation strategy for learning
switches.  Ours is based on the one given in the OpenFlow
tutorial\index{OpenFlow!tutorial} \cite{github:pox.tutorial}.
There are additional checks that we don't perform, such as
asserting that the source and destination ports are not the same when
installing flow entries (see, e.g., the pseudo-code in figure 3 of
\cite{Canini:2012:NWT:2228298.2228312}).
