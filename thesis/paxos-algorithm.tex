\section{Full Paxos}

\todo{This is not really FULL Paxos, still it's the "insanely simple"}

\begin{algorithm}[H]
  \caption{Proposer $c$: The full Paxos algorithm (Classic Crash Paxos)}
  \label{algorithm:paxos.full.proposer}
  \begin{algorithmic}
    \State $A$
    \State $crnd \leftarrow 0$

    \On[$\langle \texttt{TRUST}, c \rangle$]{$\Omega_c$}
      \State $crnd \leftarrow \text{pickNext}(crnd)$
      \State $MV \leftarrow \emptyset$
      \State \textbf{send}~$\langle \texttt{PREPARE}, crnd \rangle$ to $A$
    \EndOn
  \end{algorithmic}
\end{algorithm}

Algorithm \ref{algorithm:paxos.full.proposer} happens during the proposer's
first phase, here called \textit{1a}.  Here, $A$ is the set of acceptors and
$crnd$ is the current round number.  It is initialized to zero.

When the proposer receives a \texttt{TRUST} message from $\Omega_c$, it will
pick the proposal number larger than $crnd$, initialize the set of
$(round, vote~value)$ tuples and then send a \texttt{PREPARE} message to all
acceptors $A$.

\section{A simplified Paxos implementation}

In this chapter we will look at a simplified implementation of Paxos as
given in \cite{Insane.Paxos}.

It has been simplified to serve our needs, i.e.~to be able to handle
\texttt{ACCEPT} and \texttt{LEARN}--messages.  We can therefore remove the
$vrnd$ altogether.

\todo{
  Skriv mer om hvilke forenklinger vi har gjort.
  Forenkle mer, feks trenger vi vel ikke VRND lenger siden vi ikke bruker
  PROMISE og sånt?
}

\begin{algorithm}[H]
  \caption{Acceptor algorithm for processing \texttt{ACCEPT}--messages}
  \label{paxos.algorithm.acceptor}
  \begin{algorithmic}
    % Initialization
    \State $L$\Comment{The set of learners}
    \State $rnd \leftarrow 0$ \Comment{Current round number}
%    \State $vrnd \leftarrow \bot$ \Comment{Last voted round number}
    \State $vval \leftarrow \bot$ \Comment{Packet ID of last round}

    \On[$\langle \texttt{ACCEPT}, n, v \rangle$]{$leader$}
      \If{$n \geq rnd$} % \wedge n \neq vrnd$}
        \State $rnd\gets n$
%        \State $vrnd\gets n$
        \State $vval\gets v$
        \ForIn[$learner$]{$L$}
           \State \textbf{send} $\langle \texttt{LEARN}, n, v \rangle $ to $learner$
        \EndForIn
      \EndIf
    \EndOn
  \end{algorithmic}
\end{algorithm}

\paragraph{TODO...}

Poenget med ACCEPT-algoritmen er at vi sannsynligvis må lage en ny måte å
MATCHE på hvor n >= rnd, altså en MATCH\_{}GT eller noe sånt.  Comparison
matching... sjekk etter litteratur på om noen andre har gjort noe sånt.
Altså, istedenfor å matche på at FELT A == VERDI B så kan vi matche på FELT
A >= VERDI B, med rene bits... DET skal være godt nok!  SÅ hvis den MATCHER
så kan ACTION være å FLOODE, men KUN på lokal switch (dvs ikke til andre
switcher)..

dvs, JO den kan floode alt egentlig (utenom WAN), så må de
andre switchene bare ha regler som ignorerer LEARN-messages! Det den også må
ha er jo buffer-kontroll, lagring av pakke-IDer og rnd og vval og muligens
også fragmentering...  dvs enten bufrer switch pakken eller så bufrer
endesystem med fragmentering

... når det gjelder dette med L, RND og VVAl initialisering så må vi bare ha
et hashtable eller noe hvor vi har feks en 128-bit eller 64-bit nøkkel og
32-64-128 bit verdi... dvs, trenger ikke engang være hashtable, det kan bare
være en statisk array (vector), si vi har en array med 256 elementer som
hver har 32-bits verdier.. da kan switchen selv holde styr på at i slot 0 så
ligger RND og i slot 1 så ligger VVAL.. kan til og med klare oss med enda
færre verdier..

SISTE vi må ha er jo å kunne sende pakker mellom switchene....
TODO --- finn ut om det finnes en effektiv måte å kommunisere mellom
switcher i openflow.. tviler på det... ah, nei, de må jo kommunisere på helt
ordinær måte... aner ikke hva som er best.. kan vi feks utnytte ICMP til
dette? eller må vi faktisk lage en UDP pakker eller noe sånt?
switchene må kunne konstruere sånne pakker, legge inn verdier
(PUT VALUE-FROM-ARRAY-AT(POSITION=0) INTO PACKET, SEND PACKET TO w.x.y.z)

Er gjørbart dette her med greie primitiver... det som mangler da i oppgaven
er jo å kunne "bevise" at disse primitivene KANSKJE/SANNSYNLIGVIS kan brukes
til andre ting enn Paxos også, ellers er det jo ikke vits..

oppgaven må også fortelle hvorfor vi havnet i denne myra, dvs først vise hva
vil vil gjøre, så hvorfor det ikke lar seg gjøre i openflow, og så hvordan
vi har utvidet openflow + openvswitch for å kunne gjøre dette....
samt skissere nye openflow-protokoll-meldinger for disse nye actions...)

\textbf{Må ha med dette stykket tekst:}

What we want to avoid is to implement a complete, Turing--complete
programming language on the switch.  If that was our intention, we should
simply have used a platform that already had that, like Intel's NetVM
platform (??).

Instead, what we want is to provide \textit{simple} primitives that can be
implemented to run \textit{efficiently} on the hardware---requiring little
memory and few cycles per operation---while still being useful for other
networking protocols. (back up this statement on the last part)

In fact, our solution can, in fact, be implemented in a branchless manner on the
switch CPU, meaning that one can fill up the instruction pipeline for
maxiumem performance.  Our tables are simple vectors, meaning they
have constant time read and write operations and use little memory
(giving the benefit of improved memory locality).  In addition, the
low--level read and write instructions require extremely few cycles to run.

We think this is a good implementation for fastidious hardware implementors.

\begin{algorithm}[H]
  \caption{Learner algorithm for processing \texttt{LEARN}--messages}
  \label{paxos.algorithm.learner}
  \begin{algorithmic}
    \On[$\langle \texttt{LEARN}, n, v \rangle$]{$acceptor$}
      \ForIn[$host$]{$switch$}
        \State $\textbf{send}~\langle \texttt{PROCESS}, n, v \rangle$ to $host$
      \EndForIn
    \EndOn
  \end{algorithmic}
\end{algorithm}
% TODO: Her betyr "PROCESS" at man skal sørge for at pakken havner hos
% endesystem, i vårt tilfelle at vi sender siste fragmenteringspakke.
% TODO: Kan vi bruke QoS-queue til å bufre pakker?
% TODO: Grunnen til vi sender n,v i PROCESS er at vi FLOODER.. eh vent, vi
% kan ikke floode, kan vi vel? vi må jo faktisk BARE sende til switcher..
% dette kan MULIGENS løses ved å bruke en GROUP i en av de nyere
% openflow-versjonene, så kan vi legge alle switcher inn i en gruppe-tabell
% og forwarde til de som står der..
% ... når systemet starter må switchene oppdage hverandre.. det kan gjøres
% ved å sende ut spesielle HELLO-meldinger som bare switchene snapper opp...
% feks at vi bruker denne tabellen vår og matcher kun på visse typer
% meldinger..

\begin{table}[H]
\begin{tabular}{|l|l|}
\hline \textbf{Field} & \textbf{Description} \\
\hline \texttt{rnd} & Highest round seen \\
%\hline \texttt{vrnd} & Round in which a value was last accepted \\
\hline \texttt{vval} & Packet ID last accepted \\
\hline
\end{tabular}
\caption{Data required for the acceptor role}
\label{paxos.acceptor.fields}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|}
\hline \textbf{Field} & \textbf{Description} \\
\hline \texttt{val} & Consensus value \\
\hline
\end{tabular}
\caption{Data required for the learner role}
\label{paxos.learner.fields}
\end{table}
