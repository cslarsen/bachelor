\section{Paxos pseudo--code}

Algorithm \ref{algorithm:paxos.full.proposer} is for the Paxos proposer
role.  \texttt{TRUST}--messages are received during phase 1a, and
\texttt{PROMISE}s are received during phase 2a \cite{Lam01}.

\begin{algorithm}
  \caption{Classic crash Paxos --- Proposer $c$ (leader)}
  \label{algorithm:paxos.full.proposer}
  \begin{algorithmic}

    \State $A$
    \State $crnd \gets 0$
    \State

    \On{$\langle \texttt{TRUST}, c \rangle$}{$\Omega_c$}
      \State $crnd \gets \textbf{pickNext}(crnd)$ \Comment{Phase 1a}
      \State $MV \gets \emptyset$
      \State \SendTo{$\langle \texttt{PREPARE}, crnd \rangle$}
                    {$A$}
    \EndOn
    \State

    \On{$\langle \texttt{PROMISE}, rnd, vrnd, vval \rangle$}
       {$\text{acceptor}\ a$} \Comment{Phase 2a}
      \If{$rnd = crnd$}
        \State $MV \gets MV \cup \langle vrnd, vval \rangle$
        \If{$|MV| \geq n_a - t_a$}
          \If{$(vrnd = \bot)\ \forall \langle vrnd, vval \rangle \in MV$}
            \State $cval \gets \textbf{pickAny}()$
          \Else
            \State $cval \gets \textbf{pickLargest}(MV)$
          \EndIf
         \State \SendTo{$\langle \texttt{ACCEPT}, crnd, cval \rangle$}
                       {$A$}
        \EndIf
      \EndIf
    \EndOn

  \end{algorithmic}
\end{algorithm}

First is the initialization for the proposer. It has access to the set of
all acceptors $A$.  It also sets the current round number $crnd$ to
zero\todo{Set it to our node id instead, and then pickNext will increment it
  by the total number of nodes, so that each crnd is unique, this is a
    common trick}.

Upon receiving a \texttt{TRUST} message from $\Omega_c$, it will
pick the proposal number larger than $crnd$\todo{increment by number of
nodes}, reset the set of $\langle round, vote~value\rangle$ tuples and then send a \texttt{PREPARE} message to all
acceptors $A$.  Finally, it will send a \texttt{PREPARE} message to all
acceptors.

\begin{algorithm}
  \caption{Classic crash Paxos --- Acceptor $a$}
  \label{algorithm:paxos.full.acceptor}
  \begin{algorithmic}
    \State $P$
    \State $L$
    \State $rnd \gets 0$
    \State $vrnd \gets \bot$
    \State $vval \gets \bot$
    \State

    \On{$\langle \texttt{PREPARE}, n \rangle$}
       {$\text{proposer}\ c$} \Comment{Phase 1b}
      \If{$n > rnd$}
         \State $rnd \gets n$
         \State \SendTo{$\langle \texttt{PROMISE}, rnd, vrnd, vval\rangle$}
                       {$c$}
      \EndIf
    \EndOn
    \State

    \On{$\langle \texttt{ACCEPT}, n, v \rangle$}
       {$\text{proposer}\ c$} \Comment{Phase 2b}
      \If{$n \geq rnd \wedge n \neq vrnd$}
        \State $rnd \gets n$
        \State $vrnd \gets n$
        \State $vval \gets v$
        \State \SendTo{$\langle \texttt{LEARN}, n, v \rangle$}
                      {$L$}
      \EndIf
    \EndOn
  \end{algorithmic}
\end{algorithm}


\section{Simplifying the Paxos implementation}

In this chapter we will look at a simplified implementation of Paxos as
given in \cite{Insane.Paxos}.

It has been simplified to serve our needs, i.e.~to be able to handle
\texttt{ACCEPT} and \texttt{LEARN}--messages.  We can therefore remove the
$vrnd$ altogether.

\todo{
  Skriv mer om hvilke forenklinger vi har gjort.
  Forenkle mer, feks trenger vi vel ikke VRND lenger siden vi ikke bruker
  PROMISE og sånt?
}

Also, instead of initializing $crnd$ to zero, we will set it to the node's
unique ID.  Then, in $\textbf{pickNext}$, we will simply increment $crnd$
with the total number of Paxos nodes in the system.  This is a common trick
to ensure that each and every $crnd$ will be unique in the system and has
the added benefit that we can deduce the node ID by taking
$crnd\ (\bmod\ |N|)$, or taking the $crnd$ modulus the number of Paxos nodes
$|N|$ in the system:

Given
\begin{gather}
  crnd_i = \left\{
             \begin{array}{ll}
               n_{id} & \mbox{for } i = 0 \\
               crnd_{i-1} + |N| & \mbox{for } i \geq 1
             \end{array}
           \right. , n \in N
\end{gather}
then
\begin{gather}
  n_{id} \equiv crnd\ (\bmod\ |N|)\ \text{for}\ n \in N
  \label{equation:crnd_mod_N}
\end{gather}

where $n$ is the node and $N$ is the set of all nodes.  This leads to our
definition of $\textbf{pickNext}$ in algorithm
\ref{algorithm:paxos.simplified.pickNext}.

\begin{algorithm}
  \caption{Definition of \textbf{pickNext} based on equation \ref{equation:crnd_mod_N}}
  \label{algorithm:paxos.simplified.pickNext}
  \begin{algorithmic}
    \State $N$ \Comment{The set of all Paxos nodes}
    \State $n_{id} \gets \text{Unique Paxos node id}$
    \State $crnd \gets n_{id}$ \Comment{Replaces initialization of $crnd$ in algorithm \ref{algorithm:paxos.full.proposer}}
    \State
    \Function{$\textbf{pickNext}$}{}
      \State $\textbf{return}\ crnd + |N|$ \Comment{Unique per equation \ref{equation:crnd_mod_N}}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

As you can see in algorithm \ref{algorithm:paxos.simplified.pickNext} we
also need to initialize $crnd$ in a new way.

\begin{algorithm}
  \caption{Acceptor algorithm for processing \texttt{ACCEPT}--messages}
  \label{algorithm:paxos.simple.acceptor}
  \begin{algorithmic}
    % Initialization
    \State $L$\Comment{The set of learners}
    \State $rnd \gets 0$ \Comment{Current round number}
    %\State $vrnd \gets \bot$ \Comment{Last voted round number}
    \State $vval \gets \bot$ \Comment{Packet ID of last round}
    \State
    \On{$\langle \texttt{ACCEPT}, n, v \rangle$}{$leader$}
      \If{$n \geq rnd$} % \wedge n \neq vrnd$}
        \State $rnd\gets n$
        %\State $vrnd\gets n$
        \State $vval\gets v$
        \ForIn{$learner$}{$L$}
           \State \SendTo{$\langle \texttt{LEARN}, n, v \rangle$}
                         {$learner$}
        \EndForIn
      \EndIf
    \EndOn
  \end{algorithmic}
\end{algorithm}

Implementing algorithm \ref{algorithm:paxos.simple.acceptor} in a
combination of OpenFlow and Forth, it will be like this:

\begin{verbatim}
on <ACCEPT, n, v> from leader:
  - OpenFlow: Match on ether_type = PAXOS
  - OpenFlow: Match on in_port = LEADER
  - OpenFlow: Match on package type = UDP
  - OpenFlow: Execute bytecode with packet as parameter
  - OpenFlow: If return code == 1, then we have a new packet on
              the return stack, this will be sent out to all learners

The Forth code will then be able to extract data from the packet, in
pseudo-Forth code:

  ( on stack: packet )
  UDP.EXTRACT.OFFSET 1234 32 ( packet n )
  OVER ( n packet )
  UDP.EXTRACT.OFFSET 4567 32 ( n packet v )
  OVER ( n v packet )
  DROP ( n v )
  >= IF
    rnd! ( rnd <- n )
    vval! ( vval <- v )
    1 ( return value: OK, send packet )
  0 ELSE ( return value: FAILED, drop packet )

So in short form

  : EXTRACT.PAXOS.ACCEPT ( packet -- n v )
      EXTRACT.UDP 1234 32 OVER
      EXTRACT.UDP 4567 32 OVER
      DROP ;

  EXTRACT.PAXOS.ACCEPT
  >= IF
    rnd! vval!
    " LEARN " rnd@ vval@ CREATE.PAXOS.PACKET
    1
  ELSE
    0
  THEN

Unsure how readable that was, here's a lowercase version:

  : extract.paxos.accept ( packet -- n v )
      extract.udp 0 32 over
      extract.udp 32 32 over
      drop ;

  : create.paxos.learn ( n v -- packet )
    " LEARN " ( n v learn )
    rot ( v learn n )
    rot ( learn n v )
    create.udp.packet ;

  extract.paxos.accept
  dup2 >= if
    rnd! vval! create.udp.packet 1
  else
    0
  then

NOTE: We need a parameter that says how many cycles to run forth programs
before exiting. The controller can tell the switch how many cycles it should
run a program (or number of bytecode instructions), if it uses more than
this it terminates it.. This is to avoid that the switch loops forever in
buggy code.
\end{verbatim}

\paragraph{TODO...}

Poenget med ACCEPT-algoritmen er at vi sannsynligvis må lage en ny måte å
MATCHE på hvor n >= rnd, altså en MATCH\_{}GT eller noe sånt.  Comparison
matching... sjekk etter litteratur på om noen andre har gjort noe sånt.
Altså, istedenfor å matche på at FELT A == VERDI B så kan vi matche på FELT
A >= VERDI B, med rene bits... DET skal være godt nok!  SÅ hvis den MATCHER
så kan ACTION være å FLOODE, men KUN på lokal switch (dvs ikke til andre
switcher)..

dvs, JO den kan floode alt egentlig (utenom WAN), så må de
andre switchene bare ha regler som ignorerer LEARN-messages! Det den også må
ha er jo buffer-kontroll, lagring av pakke-IDer og rnd og vval og muligens
også fragmentering...  dvs enten bufrer switch pakken eller så bufrer
endesystem med fragmentering

... når det gjelder dette med L, RND og VVAl initialisering så må vi bare ha
et hashtable eller noe hvor vi har feks en 128-bit eller 64-bit nøkkel og
32-64-128 bit verdi... dvs, trenger ikke engang være hashtable, det kan bare
være en statisk array (vector), si vi har en array med 256 elementer som
hver har 32-bits verdier.. da kan switchen selv holde styr på at i slot 0 så
ligger RND og i slot 1 så ligger VVAL.. kan til og med klare oss med enda
færre verdier..

SISTE vi må ha er jo å kunne sende pakker mellom switchene....
TODO --- finn ut om det finnes en effektiv måte å kommunisere mellom
switcher i openflow.. tviler på det... ah, nei, de må jo kommunisere på helt
ordinær måte... aner ikke hva som er best.. kan vi feks utnytte ICMP til
dette? eller må vi faktisk lage en UDP pakker eller noe sånt?
switchene må kunne konstruere sånne pakker, legge inn verdier
(PUT VALUE-FROM-ARRAY-AT(POSITION=0) INTO PACKET, SEND PACKET TO w.x.y.z)

Er gjørbart dette her med greie primitiver... det som mangler da i oppgaven
er jo å kunne "bevise" at disse primitivene KANSKJE/SANNSYNLIGVIS kan brukes
til andre ting enn Paxos også, ellers er det jo ikke vits..

oppgaven må også fortelle hvorfor vi havnet i denne myra, dvs først vise hva
vil vil gjøre, så hvorfor det ikke lar seg gjøre i openflow, og så hvordan
vi har utvidet openflow + openvswitch for å kunne gjøre dette....
samt skissere nye openflow-protokoll-meldinger for disse nye actions...)

\textbf{Må ha med dette stykket tekst:}

What we want to avoid is to implement a complete, Turing--complete
programming language on the switch.  If that was our intention, we should
simply have used a platform that already had that, like Intel's NetVM
platform (??).

Instead, what we want is to provide \textit{simple} primitives that can be
implemented to run \textit{efficiently} on the hardware---requiring little
memory and few cycles per operation---while still being useful for other
networking protocols. (back up this statement on the last part)

In fact, our solution can, in fact, be implemented in a branchless manner on the
switch CPU, meaning that one can fill up the instruction pipeline for
maxiumem performance.  Our tables are simple vectors, meaning they
have constant time read and write operations and use little memory
(giving the benefit of improved memory locality).  In addition, the
low--level read and write instructions require extremely few cycles to run.

We think this is a good implementation for fastidious hardware implementors.

\begin{algorithm}
  \caption{Learner algorithm for processing \texttt{LEARN}--messages}
  \label{paxos.algorithm.learner}
  \begin{algorithmic}
    \On{$\langle \texttt{LEARN}, n, v \rangle$}{$acceptor$}
      \ForIn{$host$}{$switch$}
        \State \SendTo{$\langle \texttt{PROCESS}, n, v \rangle$}
                      {$host$}
      \EndForIn
    \EndOn
  \end{algorithmic}
\end{algorithm}
% TODO: Her betyr "PROCESS" at man skal sørge for at pakken havner hos
% endesystem, i vårt tilfelle at vi sender siste fragmenteringspakke.
% TODO: Kan vi bruke QoS-queue til å bufre pakker?
% TODO: Grunnen til vi sender n,v i PROCESS er at vi FLOODER.. eh vent, vi
% kan ikke floode, kan vi vel? vi må jo faktisk BARE sende til switcher..
% dette kan MULIGENS løses ved å bruke en GROUP i en av de nyere
% openflow-versjonene, så kan vi legge alle switcher inn i en gruppe-tabell
% og forwarde til de som står der..
% ... når systemet starter må switchene oppdage hverandre.. det kan gjøres
% ved å sende ut spesielle HELLO-meldinger som bare switchene snapper opp...
% feks at vi bruker denne tabellen vår og matcher kun på visse typer
% meldinger..

\begin{table}
\begin{tabular}{|l|l|}
\hline \textbf{Field} & \textbf{Description} \\
\hline \texttt{rnd} & Highest round seen \\
%\hline \texttt{vrnd} & Round in which a value was last accepted \\
\hline \texttt{vval} & Packet ID last accepted \\
\hline
\end{tabular}
\caption{Data required for the acceptor role}
\label{paxos.acceptor.fields}
\end{table}

\begin{table}
\begin{tabular}{|l|l|}
\hline \textbf{Field} & \textbf{Description} \\
\hline \texttt{val} & Consensus value \\
\hline
\end{tabular}
\caption{Data required for the learner role}
\label{paxos.learner.fields}
\end{table}
