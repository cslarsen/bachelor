\section{The full Paxos algorithms}

The Paxos\index{Paxos} papers by Lamport \cite{Lamport:1998:PP:279227.279229,Lam01}
do not describe a specific implementation algorithm.
Details such as liveness\index{liveness} checking, message structures and so on have
been omitted because they are irrelevant to the algorithm at large and may be
different from implementation to implementation.  Even though Paxos
is conceptually simple, it has been shown to be non-trivial to implement
\cite{Chandra:2007:PML:1281100.1281103}.

Our implementation has therefore been based 
\cite{Insane.Paxos}, which in turn is a condensed form of the ones given in 
\cite{renesse.paxos,Lam01}.
%
Algorithms \ref{algorithm:paxos.full.proposer} and
\ref{algorithm:paxos.full.acceptor} implement full, non-Byzantine Paxos.
We will simplify these later on.  These algorithms do not perform \textit{leader
election}.

\begin{algorithm}
  \caption{Full, classic crash Paxos --- Proposer $c$ (leader)}
  \label{algorithm:paxos.full.proposer}
  \begin{algorithmic}

    \State $A$ \Comment{Set of acceptors}
    \State $crnd \gets 0$ \Comment{Current round (unique)}
    \State

    \On{$\langle \texttt{TRUST}, c \rangle$}{$\Omega_c$}
      \State $crnd \gets \textbf{pickNext}(crnd)$ \Comment{Phase 1a}
      \State $MV \gets \emptyset$ \Comment{Set of $\langle round, vote\ value \rangle$ tuples}
      \State \SendTo{$\langle \texttt{PREPARE}, crnd \rangle$}{$A$}
    \EndOn
    \State

    \On{$\langle \texttt{PROMISE}, rnd, vrnd, vval \rangle$}
       {$\text{acceptor}\ a$} \Comment{Phase 2a}
      \If{$rnd = crnd$}
        \State $MV \gets MV \cup \langle vrnd, vval \rangle$
        \If{$|MV| \geq n_a - t_a$}
          \If{$(vrnd = \bot)\ \forall\ \langle vrnd, vval \rangle \in MV$}
            \State $cval \gets \textbf{pickAny}()$
          \Else
            \State $cval \gets \textbf{pickLargest}(MV)$
          \EndIf
         \State \SendTo{$\langle \texttt{ACCEPT}, crnd, cval \rangle$}
                       {$A$}
        \EndIf
      \EndIf
    \EndOn

  \end{algorithmic}
\end{algorithm}
\index{Paxos!proposer algorithm}

Algorithm \ref{algorithm:paxos.full.proposer}
\vpageref{algorithm:paxos.full.proposer} is for the \textit{proposer
role}.  \texttt{TRUST}-messages are received during phase 1a, and
\texttt{PROMISE}s are received during phase 2a. See \cite{Lam01} for details.

First we initialize the proposer. We assume it already knows (the addresses
of) the acceptors $A$.  The current round number $crnd$ is initialized to
zero, although later we will implement a version that guarantees a sequence
of unique $crnd$s (shown in equations \ref{equation:crnd_i} and
\ref{equation:crnd_mod_N}).

Upon receiving a \texttt{TRUST} message from $\Omega_c$, it will pick the
proposal number larger than $crnd$, reset the set of
$\langle round, vote~value\rangle$ tuples and then send a
\texttt{PREPARE} message to all acceptors $A$.  Finally, it will
send a \texttt{PREPARE} message to all acceptors.
%
The implementation of \textbf{pickNext} is found in
algorithm \ref{algorithm:paxos.simple.pickNext},
\vpageref[below]{ch:simplifying.paxos}.

When it receives a \texttt{PROMISE}, it will first check that it is a reply
that belongs in the current round.  It will store the acceptor's $vrnd$ and
$vval$, then it will check whether it has received accepts from a
\textit{majority} of acceptors\todo{Forklar algorithmen, $n_a - t_a$.}.
If will also check that it has not already accepted this message.
If it has, then it will simply resend the \texttt{ACCEPT}ed value.
If it hasn't, it will go on and send the next value from its buffer.
We don't show implementations for \textbf{pickAny} or \textbf{pickLargest},
but one can imagine these are simple queues of messages to process.
\todo{Sjekk at dette er korrekt! Og ikke glem at vi må ha med en ekstra
  verdi i vrnd/vval tuple!}

\begin{algorithm}[H]
  \caption{Full, classic crash Paxos --- Acceptor $a$}
  \label{algorithm:paxos.full.acceptor}
  \begin{algorithmic}
    \State $P$ \Comment{Set of proposers}
    \State $L$ \Comment{Set of learners}
    \State $rnd \gets 0$ \Comment{Highest round seen}
    \State $vrnd \gets \bot$ \Comment{Round in which value was last accepted}
    \State $vval \gets \bot$ \Comment{Value last accepted}
    \State

    \On{$\langle \texttt{PREPARE}, n \rangle$}
       {$\text{proposer}\ c$} \Comment{Phase 1b}
      \If{$n > rnd$}
         \State $rnd \gets n$
         \State \SendTo{$\langle \texttt{PROMISE}, rnd, vrnd, vval\rangle$}
                       {$c$}
      \EndIf
    \EndOn
    \State

    \On{$\langle \texttt{ACCEPT}, n, v \rangle$}
       {$\text{proposer}\ c$} \Comment{Phase 2b}
      \If{$n \geq rnd \wedge n \neq vrnd$}
        \State $rnd \gets n$
        \State $vrnd \gets n$
        \State $vval \gets v$
        \State \SendTo{$\langle \texttt{LEARN}, n, v \rangle$}
                      {$L$}
      \EndIf
    \EndOn
  \end{algorithmic}
\end{algorithm}
\index{Paxos!acceptor algorithm}

Algorithm \ref{algorithm:paxos.full.acceptor}
\vpageref{algorithm:paxos.full.acceptor} is for the \textit{acceptor
role}.  It will act on \texttt{PREPARE} and \texttt{ACCEPT} messages.
When \texttt{PREPARE} is received, it will simply check if the round number
is larger than the highest round it has seen so far.  If so, it will update
its round number $rnd$ and send back a \texttt{PROMISE} to the acceptor.
\todo{Tar den bare imot prepares fra lederen? Kan virke sånn, siden
algoritmen sier spesifikt at c er leder!}

Upon receiving an \texttt{ACCEPT} message, it will again check if the round
number is equal to or larger than the largest it has already seen, and that
it has not already accepted that value.  If this is the case, it will update
its values and send a \texttt{LEARN}-message to \textit{all} learners.

The full Paxos algorithm for the \textit{learner role} has been omitted, but
we will detail one for the simplified version.

\clearpage
\section{The simplified Paxos algorithms}
\label{ch:simplifying.paxos}

In this chapter we will look at a simplified implementation of Paxos as
given in algorithms \ref{algorithm:paxos.full.proposer} and
\ref{algorithm:paxos.full.acceptor}.

It has been simplified to serve our needs, i.e.~to be able to handle
\texttt{ACCEPT} and \texttt{LEARN}-messages.  We can therefore remove the
$vrnd$ altogether.  Also, each Paxos node in our system will take on all
three roles, so we don't need separate sets for the acceptors, learners and
proposers. We will instead use simply $N$ for the set of Paxos nodes.

We need $crnd$ to be a sequence of \textit{unique} values for all Paxos
nodes.
Instead of initializing it to zero, we will set it to the node's
unique ID.  Then, in $\textbf{pickNext}$, we will simply increment $crnd$
with the total number of Paxos nodes in the system.  This
is a common trick to ensure that each and every $crnd$ will be unique in the
system and has
the added benefit that we can deduce the node ID by taking
$crnd\ (\bmod\ |N|)$, or taking the $crnd$ modulus the number of Paxos nodes
$|N|$ in the system:\index{Paxos!round number}

Given
\begin{gather}
  crnd_i = \left\{
             \begin{array}{ll}
               n_{id} & \mbox{for } i = 0 \\
               crnd_{i-1} + |N| & \mbox{for } i \geq 1
             \end{array}
           \right. , n \in N
  \label{equation:crnd_i}
\end{gather}
then, by definition,
\begin{gather}
  n_{id} \equiv crnd\ (\bmod\ |N|)\ \text{for}\ n \in N
  \label{equation:crnd_mod_N}
\end{gather}

where $n$ is the node and $N$ is the set of all nodes.  This leads to our
definition of $\textbf{pickNext}$ in algorithm
\ref{algorithm:paxos.simple.pickNext}.

\begin{algorithm}
  \caption{Definition of \textbf{pickNext} based on equation \ref{equation:crnd_mod_N}}
  \label{algorithm:paxos.simple.pickNext}
  \begin{algorithmic}
    \State $N$ \Comment{The set of all Paxos nodes}
    \State $n_{id} \gets \text{Unique Paxos node id}$
    \State $crnd \gets n_{id}$ \Comment{Replaces initialization of $crnd$ in algorithm \ref{algorithm:paxos.full.proposer}}
    \State
    \Function{$\textbf{pickNext}$}{}
      \State $\textbf{return}\ crnd + |N|$ \Comment{Unique per equation \ref{equation:crnd_mod_N}}
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\index{Paxos!round number}

As we only intend to show that we can implement \texttt{ACCEPT} and
\texttt{LEARN}, we can ignore \texttt{TRUST}, \texttt{PROMISE} and
\texttt{PREPARE}-messages.  This leaves us with the very simple algorithms
\ref{algorithm:paxos.simple.acceptor} and
\ref{algorithm:paxos.simple.learner}.  The proposer algorithm will be done
with OpenFlow flow table entries (see \ref{chapter:incoming.client}
    and \ref{chapter:final.flowtable} on pages
    \pageref{chapter:final.flowtable} and 
    \pageref{chapter:incoming.client}, respectively).

\begin{algorithm}
  \caption{Simplified algorithm for processing \texttt{ACCEPT}-messages}
  \label{algorithm:paxos.simple.acceptor}
  \begin{algorithmic}
    \State $N$\Comment{The set of Paxos nodes}
    \State $rnd \gets 0$ \Comment{Current round number}
    \State $vval \gets \bot$ \Comment{Packet ID of last round}
    \State

    \On{$\langle \texttt{ACCEPT}, n, v \rangle$}{$leader$}
      \If{$n \geq rnd$} % \wedge n \neq vrnd$}
        \State $rnd\gets n$
        \State $vval\gets v$ \Comment{The client packet ID}
        \ForIn{$node$}{$N$}
           \State \SendTo{$\langle \texttt{LEARN}, n, v \rangle$}
                         {$node$}
        \EndForIn
      \EndIf
    \EndOn
  \end{algorithmic}
\end{algorithm}
\index{Paxos!accept}

As for handling \texttt{LEARN}-messages, we can proceed to send the last
fragment of the client packet to the end-hosts when we have received a
learn from a majority.

\begin{algorithm}[H]
  \caption{Simplified algorithm for processing \texttt{LEARN}-messages}
  \label{algorithm:paxos.simple.learner}
  \begin{algorithmic}
    \State $H$ \Comment{The set of end-hosts connected to this switch}
    \State

    \On{$\langle \texttt{LEARN}, n, v \rangle$}{$acceptor$}
      \If{$got\_{}majority(n)$}
        \ForIn{$host$}{$H$}
          \State \SendTo{$ last\_{}fragment(v) $}{$host$}
        \EndForIn
      \EndIf
    \EndOn
  \end{algorithmic}
\end{algorithm}
\index{Paxos!learn}
