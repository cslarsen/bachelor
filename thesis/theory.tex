\chapter{Background}
\label{chapter:background}

\section{Software-Defined Networking}
\label{chapter:background.openflow}

Software-defined networking (\acs{SDN}) \cite{openflow.whitepaper.2012}
\index{software-defined networking}\index{SDN|see{software-defined networking}}
is all about building, deploying and managing networks using
\textit{software}.\todo{No, it's really not only that.. rewrite}

Central to this idea is to decouple the \textit{control} and
\textit{forwarding} planes
(see figures \ref{figure:decoupling.planes} and \ref{figure:coupling.planes}).
The forwarding plane is also called the \textit{data plane}.

While routers traditionally contained both in hardware, one would now move
the controller out to an external device---e.g.~as a software component
running on a server.  The two would then communicate over a secure network
channel, using a predetermined protocol.

\section{OpenFlow}
\label{chapter:openflow.background}

OpenFlow \cite{McKeown:2008:OEI:1355734.1355746,openflow-1.0} is one of
several ways to implement \acs{SDN}.
%
It specifies a messaging protocol for the interaction between the switch and
controller, and details capabilities that the switch can perform.
%
Examples of \ac{SDN} solutions predating OpenFlow are SANE
\cite{Casado:2006:SPA:1267336.1267346}, Ethane
\cite{Casado:2007:ETC:1282427.1282382}, 4D
\cite{Greenberg:2005:CSA:1096536.1096541}.

In OpenFlow, the controller can inspect packets and send commands down to
the switch to have it perform actions like changing header fields of a
packet, forward it to a port, drop it and so on.
%
In addition, the switch can be instructed to perform such actions by itself,
using a \textit{flow table}.
%
The flow table consists of several flow entries---or \textit{flows}.
%
These contain rules for matching packets and actions to perform when there
is a match.
%
In addition there are several counters used for monitoring the number of
executions, timeouts to control the life-time of entries, and so on.

Any software or hardware device that conforms to the protocol can be used to
run OpenFlow.  Most commonly, the controller runs as a program a some host.
%
This enables arbitrarily complex operation, as implementors can program the
controller in any language supporting the protocol.
%
Running on servers also means that the controllers can interact with 
\textit{any} other service.

You can program the controller in any language framework that supports the
OpenFlow specification, and the switches themselves can run either on
hardware or in software.  Several hardware vendors now ship
OpenFlow-enabled switches.

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={draw, circle},
                        node distance=2.5cm]
      \node [rectangle,
             rounded corners,
             minimum width=3cm,
             minimum height=1cm] (Sbig) at (0,0) {};

      \node [draw=none] (S) at (0,0) {$S$};
      \node [right=0.25cm of S] (C) {$C$};
      \node [left=0.25cm of S] (F) {$F$};

      % Add invisible node from figure B so that they align vertically
      \node [draw=none] (vspacer) [above of=S] {};

      \node (h1) [dashed, below left of=S] {};
      \node (h2) [dashed, below of=S] {};
      \node (h3) [dashed, below right of=S] {};

      \draw [dashed] (Sbig) -- (h1);
      \draw [dashed] (Sbig) -- (h2);
      \draw [dashed] (Sbig) -- (h3);

    \end{tikzpicture}
    \caption{A typical switch $S$ combines the control and
      forwarding planes ($C$ and $F$) on the same device.
        The control plane
        $C$ is usually locked down by the vendor and inaccessible to users.}
    \label{figure:coupling.planes}
  \end{subfigure}%
  \hspace*{0.1\textwidth}%
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={draw, circle},
                        node distance=2.5cm]

      \node [rectangle,
             rounded corners,
             minimum width=3cm,
             minimum height=1cm] (S) {$S$};

      \node (T) [above of=S] {$C$};
      \node (h1) [dashed, below left of=S] {};
      \node (h2) [dashed, below of=S] {};
      \node (h3) [dashed, below right of=S] {};

      \node (FlowTable) [left=-0.9cm of S] {$F$};

      \draw (T) -- (S);
      \draw [dashed] (S) -- (h1);
      \draw [dashed] (S) -- (h2);
      \draw [dashed] (S) -- (h3);

    \end{tikzpicture}
    \caption{\ac{SDN} decouples the control plane $C$ from the forwarding
      plane $F$ by moving it out of the switch $S$ to an external network
        node.  The \textit{OpenFlow protocol} enables communication between
        $S$ and $C$, making it possible to implement $C$ in software on an
        ordinary computer. The connection between $S$ and $C$ is encrypted.}
    \label{figure:decoupling.planes}
  \end{subfigure}
\end{figure}

\subsection{The Flow Table}
\label{chapter:theory.flow.table}

As the switch receives packets, it will try to match them with entries in a
\textit{flow table} (table \vref{openflow.flow.entry.spec}).
%
Each entry---or \textit{flow}---contains a matching pattern and a set of
actions to perform in the case of a match.  The actions can be to rewrite
a header field, forward the packet to a port, drop it and so on.
%
If a packet does not match any flows, the switch will forward a buffer ID
and packet headers to the controller $C_1$ on a secure channel.

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline \textbf{Header fields} &
           \textbf{Counters} &
           \textbf{Actions} \\
    \hline \dots & \dots & \dots \\
  \end{tabular}

  \caption{The OpenFlow 1.0 flow table.}
  \label{openflow.flow.entry.spec}
\end{table}

The controller can then decide what to do with the packet.  Using the
OpenFlow protocol, it can issue immediate actions to the switch or install
flows, so the switch can operate on its own.

The flow tables are initially empty, meaning that all packets are by default
sent to the controller.  During this phase, the controller will
explicitly handle every packet.  At the same time, it will incrementally
build up an internal map of the network.  As the map forms, it can start
installing flows on the switch.

For instance, if a controller learns the port numbers for a pair of
addresses, it can instruct the switch to automatically forward packets to
the appropriate ports when the two are involved.  If the ports are unknown,
it can broadcast the packet on all ports, knowing that only designated
receivers will act on them.
%
What we have described here is a \textit{learning switch}.  It is explained
in detail in chapter \vref{chapter:l2.learning.switch}.

Along with each flow entry is an associated set of timeouts.  Flows are
removed from the flow table when they time out.
%
This serves several purposes.  First of all, it makes sure that flow tables
do not fill up quickly.  Secondly, because flows---and packets---are
transient by nature, controllers will be given the chance to update rules
based on changes in the network.
%
Finally, this mode of operation adheres to the principle of autonomous
operation\index{autonomous operation} commonly seen in networking devices.
%
Properly designed controllers should not need elaborate configuration to
work.  While they initially do all the heavy-lifting, they can offload work
to the switches, who can then dispatch packets very quickly.

\subsection{OpenFlow Applications}

OpenFlow has been used for many purposes.  E.g., researchers at Stanford
build an OpenFlow network that was able to migrate a virtual video game
server \ac{VM} from California to Japan---while it was running, without
interruption, using the \textit{same} IP-address
\cite{erickson2008demonstration} \cite{kobayashi2013maturing}.
%
The campus network on Stanford in fact uses a lot of OpenFlow devices.
Google also uses it in production in their global network.

Although invented quite recently, software-defined networking is already
heavily used both in academia and industry.  Google, for instance, are using
OpenFlow to ease deployment and increase utilization in their backbone
networks \cite{crabbe2012sdn} and Stanford has deployed several
OpenFlow-controlled networks on their university network.

Since version 1.0 of the OpenFlow specification\index{OpenFlow!versions} was
released in 2009 there have been several point releases and errata.  The
most recent one as of 2014 is 1.4\index{OpenFlow!versions}
\cite{openflow-1.0,openflow-1.0.1,openflow-1.0.2,openflow-1.1,openflow-1.2,openflow-1.3,openflow-1.4}.


\section{Open vSwitch}
\label{chapter:background.openvswitch}

\section{Paxos}
\label{chapter:background.paxos}

Paxos is a distributed consensus algorithm.
\todo{Expand introduction and details}

Even though the basic Paxos algorithm is conceptually quite simple
\cite{Lam01}, it can be challenging to implement properly
\cite{Chandra:2007:PML:1281100.1281103}.
