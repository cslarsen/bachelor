\chapter{Background material}
\label{chapter:background}

\section{SDN and OpenFlow}
\label{chapter:background.openflow}

\acf{SDN}\index{software-defined networking}\index{SDN|see{software-defined
networking}} is all about building, deploying and managing networks using
\textit{software}.\todo{No, it's really not only that.. rewrite}

Central to this idea is to decouple the \textit{control} and
\textit{forwarding} planes\footnote{Also called \textit{data plane}.}
(see figures \ref{figure:decoupling.planes} and \ref{figure:coupling.planes}).
\todo{Mer om decoupling, flytt tekst fra introduksjon++ sted som forklarer mer om det}

While routers traditionally contained both in hardware, one would now move
the controller out to an external device---e.g.~as a software component
running on a server.  The two would then communicate over a secure network
channel, using a predetermined protocol.

One such protocol is \textit{OpenFlow}\index{OpenFlow}\footnote{Other
\ac{SDN} solutions predating OpenFlow are SANE
\cite{Casado:2006:SPA:1267336.1267346}, Ethane
\cite{Casado:2007:ETC:1282427.1282382}, 4D
\cite{Greenberg:2005:CSA:1096536.1096541}, etc.} % footnote
\cite{McKeown:2008:OEI:1355734.1355746}.

OpenFlow specifies a way for the controller and switch to communicate, and
details capabilities for such a system.
The controller can program the switch with packet matching rules
and associated actions like forwarding, header modifications and so on.

The controller can be a separately running program on a remote host. This
means that it can be arbitrarily complex and make decisions based on a
global overview of the networks it serves.

In OpenFlow, the controller configures so-called \textit{flow tables}\index{flow table} in the
data plane (also called \textit{forwarding plane})
  \index{data plane} which contain matching patterns and actions
for incoming packets.  These tables are designed for high performance
and are thus quite simple.  On the other hand, the controller can be
arbitrarily complex.

You can program the controller in any language framework that supports the
OpenFlow specification, and the switches themselves can run either on
hardware or in software.  Several hardware vendors now ship
OpenFlow-enabled switches.

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={draw, circle},
                        node distance=2.5cm]
      \node [rectangle,
             rounded corners,
             minimum width=3cm,
             minimum height=1cm] (Sbig) at (0,0) {};

      \node [draw=none] (S) at (0,0) {$S$};
      \node [right=0.25cm of S] (C) {$C$};
      \node [left=0.25cm of S] (F) {$F$};

      % Add invisible node from figure B so that they align vertically
      \node [draw=none] (vspacer) [above of=S] {};

      \node (h1) [dashed, below left of=S] {};
      \node (h2) [dashed, below of=S] {};
      \node (h3) [dashed, below right of=S] {};

      \draw [dashed] (Sbig) -- (h1);
      \draw [dashed] (Sbig) -- (h2);
      \draw [dashed] (Sbig) -- (h3);

    \end{tikzpicture}
    \caption{A typical switch $S$ combines the control and
      forwarding planes ($C$ and $F$) in the same package. The control plane
        $C$ is usually locked down by the vendor and inaccessible to users.}
    \label{figure:coupling.planes}
  \end{subfigure}%
  \hspace*{0.1\textwidth}%
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={draw, circle},
                        node distance=2.5cm]

      \node [rectangle,
             rounded corners,
             minimum width=3cm,
             minimum height=1cm] (S) {$S$};

      \node (T) [above of=S] {$C$};
      \node (h1) [dashed, below left of=S] {};
      \node (h2) [dashed, below of=S] {};
      \node (h3) [dashed, below right of=S] {};

      \node (FlowTable) [left=-0.9cm of S] {$F$};

      \draw (T) -- (S);
      \draw [dashed] (S) -- (h1);
      \draw [dashed] (S) -- (h2);
      \draw [dashed] (S) -- (h3);

    \end{tikzpicture}
    \caption{\ac{SDN} decouples the control plane $C$ from the forwarding
      plane $F$ by moving it out of the switch $S$ to an external network
        node.  The \textit{OpenFlow protocol} enables communication between
        $S$ and $C$, making it possible to implement $C$ in software on an
        ordinary computer. The connection between $S$ and $C$ is encrypted.}
    \label{figure:decoupling.planes}
  \end{subfigure}
\end{figure}

By default, a switch will forward the first parts of a packet that does not
match any rule.  The controller typically receives these first few bytes,
along with a buffer ID of the complete packet, and can then decide
what do to with it.  It can instruct the switch to forward the packet,
or it can add entries to the switch's flow tables so that the switch
will be able to handle specific packets by itself in the future.  This
initial passing of packets to the controller incurs a performance hit,
but as soon as the switch has entries in its flow tables, processing
is very fast and can in good implementations operate at line speed.

Since version 1.0 of the OpenFlow specification\index{OpenFlow!versions} was
released in 2009 there have been several point releases and errata.  The
most recent one as of 2014 is 1.4\index{OpenFlow!versions}
\cite{openflow-1.0,openflow-1.0.1,openflow-1.0.2,openflow-1.1,openflow-1.2,openflow-1.3,openflow-1.4}.

\subsection{Flow Tables}

The \textit{flow tables}\index{flow table} lives in a switch that supports
OpenFlow and contain \textit{flow entries} (see table
    \ref{openflow.flow.entry.spec}).  When a packet arrives, it will check
to see if any entries \textit{match} the given packet.  For instance, one
entry may want to do something with \ac{IP} packets containing the
IP-destination \texttt{10.0.0.2}, so the entry will then state that it
matches IP-packets with its destination field set to \texttt{10.0.0.2}.

Each entry also has an associated set of \textit{actions}.  These dictates
what should happen when we have a match.  In the example above, the switch
may already know that \texttt{10.0.0.2} can be reached through port 5, and
so may proceed to \textit{forward} the packet there.

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline \textbf{Header fields} &
           \textbf{Counters} &
           \textbf{Actions} \\
    \hline \dots & \dots & \dots \\
  \end{tabular}

  \caption{The OpenFlow 1.0 flow table.}
  \label{openflow.flow.entry.spec}
\end{table}

If the packet matches no flow entries, it will by default send the packet up
to the controller, letting it decide what to do with it.  This commonly
happens right after starting up an OpenFlow switch, as its flow table will
be empty.

During this phase, the controller usually gets a lot of packets from the
switch.  The controller may then decide to \textit{install} new flow entries
in the switch, so that it can operate mostly by itself.  This is also good
for performance, allowing the switch to potentially operate at linespeed.

The flow table entries also have associated counters, used to count number
of packets handled, and so on.  It also has two timeout counters.  One of
them is the \textit{idle time} counter, and resets every time there is a
match.  The controller selects this value when it installs the entry, and it
will count backwards.  If it reaches zero, the entry will be removed from
the table.

There is also a \textit{hard timeout} counter.  This never resets, and is
there to keep the flow table from getting full.  For forwarding entries, one
can, for instance, set the idle timeout to 10 seconds and the hard timeout
to 60 seconds.  This means that after 1 minute, at the latest, the switch
will remove the entry.  If a new packet arrives after this, and there is no
other match in the table, then the controller will get the packet again and
can reinstall the same entry.

As you can see, OpenFlow allows one to construct L2 learning hubs and even
routers---or you can create entirely new forwarding mechanisms.

OpenFlow has been used for many purposes.  E.g., at Stanford, they installed
an OpenFlow system that was able to migrate a video game server \ac{VM} from
California to Japan---while it was running, without interruption, using the
\textit{same} IP-address \cite{erickson2008demonstration}
\cite{kobayashi2013maturing}.
The campus network on Stanford in fact uses a lot of OpenFlow devices.
Google also uses it in production in their global network.

Although invented quite recently, software-defined networking is already
heavily used both in academia and industry.  Google, for instance, are using
OpenFlow to ease deploymend and increase utilization in their backbone
networks \cite{crabbe2012sdn} and Stanford has deployed several
OpenFlow-controlled networks on their university network.

\section{Open vSwitch}
\label{chapter:background.openvswitch}

\section{Paxos}
\label{chapter:background.paxos}

Paxos is a distributed consensus algorithm.
\todo{Expand introduction and details}

Even though the basic Paxos algorithm is conceptually quite simple
\cite{Lam01}, it can be challenging to implement properly
\cite{Chandra:2007:PML:1281100.1281103}.
