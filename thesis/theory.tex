\chapter{Theory}

\section{Paxos}
Paxos is a distributed consensus algorithm.\todo{Expand introduction and
details}.

Even though the basic Paxos algorithm in \cite{Lam01} is quite simple, it can be
a challenge to implement properly \cite{Chandra:2007:PML:1281100.1281103}.

\section{Software--defined networking}

\ac{SDN} is all about deploying and maintaining networks using software.
Central to this idea is to split up the \textit{control} and \textit{data}
planes.

\section{OpenFlow}

OpenFlow is a protocol that specifies how a switch and its controller can
communicate.

The controller can be a separately running program on a remote host. This
means that it can be arbitrarily complex and make decisions based on a
global overview of the networks it serves.

The controller program can be written in any language that implements the
OpenFlow specification, and the switches themselves can either be physical
or virtual.  In fact, many commercial network manufacturers now offer
OpenFlow--enabled switches.

By default, a switch will forward parts of a packet to the controller when
it does not know what to do with it.  The controller typically receives the
first few bytes of a packet---often along with a buffer ID pointing to the
complete packet in the switch---and can then decide what do to with it.  It
can instruct the switch to forward the packet, or it can add entries to the
switch's flow tables so that the switch will be able to handle specific
packets entirely or partly by itself in the future.  This initial passing of
packets to the controller incurs a performance hit, but as soon as the
switch has entries in its flow tables, processing is very fast.

\subsection{Flow Tables}

The \textit{flow tables} lives in a switch that supports OpenFlow and
contain \textit{flow entries}.  When a packet arrives, it will check to see
if any entries \textit{match} the given packet.  For instance, one entry may
want to do something with \ac{IP} packets containing the IP--destination
\texttt{10.0.0.2}, so the entry
will then state that it matches IP--packets with its destination field set
to \texttt{10.0.0.2}.

Each entry also has an associated set of \textit{actions}.  These dictates
what should happen when we have a match.  In the example above, the switch
may already know that \texttt{10.0.0.2} can be reached through port 5, and
so may proceed to \textit{forward}Â the packet there.

If the packet matches no flow entries, it will by default send the packet up
to the controller, letting it decide what to do with it.  This commonly
happens right after starting up an OpenFlow switch, as its flow table will
be empty.

During this phase, the controller usually gets a lot of packets from the
switch.  The controller may then decide to \textit{install} new flow entries
in the switch, so that it can operate mostly by itself.  This is also good
for performance, allowing the switch to potentially operate at linespeed.

The flow table entries also have associated counters, used to count number
of packets handled, and so on.  It also has two timeout counters.  One of
them is the \textit{idle time} counter, and resets every time there is a
match\todo{Or does it reset when it performs actions?}.  The controller
selects this value when it installs the entry, and it will count backwards.
If it reaches zero, the entry will be removed from the table.

There is also a \textit{hard timeout} counter.  This never resets, and is
there to keep the flow table from getting full.  For forwarding entries, one
can, for instance, set the idle timeout to 10 seconds and the hard timeout
to 60 seconds.  This means that after 1 minute, at the latest, the switch
will remove the entry.  If a new packet arrives after this, and there is no
other match in the table, then the controller will get the packet again and
can reinstall the same entry.

As you can see, OpenFlow allows one to construct L2 learning hubs and even
routers---or you can create entirely new forwarding mechanisms.

OpenFlow has been used for many purposes.  E.g., at Stanford, they installed
an OpenFlow system that was able to migrate a video game server \ac{VM} from
California to Japan---while it was running, without interruption, using the
\textit{same} IP--address \cite{erickson2008demonstration}
\cite{kobayashi2013maturing}.
The campus network on Stanford in fact uses a lot of OpenFlow devices.
Google also uses it in production in their global network.

\section{Forth}

\textit{Forth} is a concatenative, stack--based programming language.
Originally invented by Charles Moore in the 1970s for use with
microcontrollers, it still sees use today and has commonly been called a
trade secret for modern hardware vendors.

The reason for its use is that it lets one run interpreted code on very
restricted systems. A Forth interpreter can be extremely small\footnote{For
instance, the \textit{Ngaro virtual machine} comes with a feature--complete
implementation of Forth, and is written in only 778 lines of C code.}
and there is little overhead in interpreting the code.

Forth is usually interpreted, and most instructions are function calls.
Data lives on a stack, and words operate on them.  You also use this stack
to pass parameters to words (or functions).

To return from a word, one also needs a second \textit{return--stack}.

There is almost no syntax in Forth.  It uses \ac{RPN}, so programs tends to
be succinct and compact.  Comments are written in \texttt{( parenthesis)},
and it is common practice to write which parameters are expected on the
stack and which will be there after execution---separated by \texttt{--}.

To multiply two numbers together, you write

\begin{verbatim}
2 3 *
\end{verbatim}

The interpreter will first see the number two and push it on the stack. Next
it will push the number three on the stack. Finally, it sees a word called
\texttt{*}.  This word performs multiplication. It will consume the topmost
two numbers on the stack, multiply them together and push the result back on
the stack. So in this case the numbers 2 and 3 will be removed from the
stack, leaving 6 on the top of the stack.

To define a new word, you write

\begin{verbatim}
: square ( n -- n^2 )
    dup * ;
\end{verbatim}

The colon introduces a new word, followed by a name and all the instructions
up to the concluding semicolon.  Here you can see the comments in action,
showing how the \texttt{square} word expects a number on the stack
(\texttt{n}) and will replace it with its square.

The \texttt{dup} word will duplicate the item on the top of the stack.  We
say \textit{item} here, because Forth lets you push different type of data
on the stack.

To test this word, one can write 
\begin{verbatim}
12 square .
\end{verbatim}

which pushes 12 on the stack, replaces the number with its square
\texttt{144} and then the dot will take the number on the top of the stack
and print it.

Because of the \ac{RPN}, some bits of code seem to be in reverse.  This is
very obvious for if--statements, which are terminated by the word
\texttt{THEN}.  So to test if two numbers are equal, we first need to push
two numbers on the stack, then perform some kind of comparison (for
instance, \texttt{=} for equality--testing) and then invoke the
\texttt{IF} word.  \texttt{IF} will take the number on the top of the stack
and execute code conditionally, based on this number.  Most Forths use all
bits set to zero for the value \textit{false} and all bits set to one as
\textit{true}.  Usually, a \textit{true}--value is written using $-1$,
which has all bits set to one for systems that implement signed numbers
using two's complement.

Here is an example that prints strings based on the result of comparing two
numbers:

\begin{verbatim}
10 20
> IF
    ." 10 is bigger than 20 " CR
  ELSE
    ." 10 is not bigger than 20" CR
  THEN
\end{verbatim}

This code is equivalent to

\begin{verbatim}
if ( 10 > 20 )
  printf("10 is bigger than 20\n");
else
  printf("10 is not bigger than 20\n");
\end{verbatim}

in C.  Because parameters are passed on the stack, Forth programs tend to be
quite compact---and source code may look quite cryptic.  Because of this, it
is very important to write good word definitions.  Most words are very
short, often only a few lines.  The process of extracting small word
definitions from a source code is colloquially called \textit{factoring} in
Forth parlance.

\section{OpenVSwitch}

