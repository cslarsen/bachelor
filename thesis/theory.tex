\chapter{Background material}

\section{OpenFlow}

\acf{SDN} is all about deploying and maintaining networks using software.
Central to this idea is to decouple the \textit{control} and
\textit{forwarding}
planes\footnote{The forwarding plane is also called the \textit{data
  plane}.} planes (figure \ref{figure:decoupling.planes}).
\todo{Mer om decoupling, flytt tekst fra introduksjon++ sted som forklarer mer om det}

OpenFlow is a protocol that specifies how a switch and its controller can
communicate, letting it program the switch with packet matching rules and
associated actions like forwarding, header modifications and so on.

The controller can be a separately running program on a remote host. This
means that it can be arbitrarily complex and make decisions based on a
global overview of the networks it serves.

You can program the controller in any language framework that supports the
OpenFlow specification, and the switches themselves can run either on
hardware or in software.  Several hardware vendors now ship
OpenFlow--enabled switches.

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={draw, circle},
                        node distance=2.5cm]
      \node [rectangle,
             rounded corners,
             minimum width=3cm,
             minimum height=1cm] (Sbig) at (0,0) {};

      \node [draw=none] (S) at (0,0) {$S$};
      \node [right=0.25cm of S] (C) {$C$};
      \node [left=0.25cm of S] (F) {$F$};

      % Add invisible node from figure B so that they align vertically
      \node [draw=none] (vspacer) [above of=S] {};

      \node (h1) [dashed, below left of=S] {};
      \node (h2) [dashed, below of=S] {};
      \node (h3) [dashed, below right of=S] {};

      \draw [dashed] (Sbig) -- (h1);
      \draw [dashed] (Sbig) -- (h2);
      \draw [dashed] (Sbig) -- (h3);

    \end{tikzpicture}
    \caption{A typical switch $S$ that combines both the control and
             forwarding planes.  Contrast to figure \ref{figure:decoupling.planes}.}
    \label{coupled.planes}
  \end{subfigure}%
  \hspace*{0.1\textwidth}%
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={draw, circle},
                        node distance=2.5cm]

      \node [rectangle,
             rounded corners,
             minimum width=3cm,
             minimum height=1cm] (S) {$S$};

      \node (T) [above of=S] {$C$};
      \node (h1) [dashed, below left of=S] {};
      \node (h2) [dashed, below of=S] {};
      \node (h3) [dashed, below right of=S] {};

      \node (FlowTable) [left=-0.9cm of S] {$F$};

      \draw (T) -- (S);
      \draw [dashed] (S) -- (h1);
      \draw [dashed] (S) -- (h2);
      \draw [dashed] (S) -- (h3);

    \end{tikzpicture}
    \caption{\ac{SDN} decouples the control plane $C$ from the forwarding
      plane $F$ by moving it out of the switch $S$.
        The \textit{OpenFlow protocol} lets $S$ and $C$ communicate over a secure
        TLS channel.}
    \label{figure:decoupling.planes}
  \end{subfigure}
\end{figure}

By default, a switch will forward the first parts of a packet that does not
match any rule.  The controller typically receives these first few bytes,
along with a buffer ID of the complete packet, and can then decide
what do to with it.  It can instruct the switch to forward the packet,
or it can add entries to the switch's flow tables so that the switch
will be able to handle specific packets by itself in the future.  This
initial passing of packets to the controller incurs a performance hit,
but as soon as the switch has entries in its flow tables, processing
is very fast and can in good implementations operate at line speed.

Version 1.0 of the OpenFlow specification was released in 2009
\cite{openflow-1.0} \cite{openflow-1.0.1} \cite{openflow-1.0.2}.
The most recent one as of 2014 is 1.4 \cite{openflow-1.4}.

\subsection{Flow Tables}

The \textit{flow tables} lives in a switch that supports OpenFlow and
contain \textit{flow entries} (see table \ref{openflow.flow.entry.spec}).
When a packet arrives, it will check to see
if any entries \textit{match} the given packet.  For instance, one entry may
want to do something with \ac{IP} packets containing the IP--destination
\texttt{10.0.0.2}, so the entry
will then state that it matches IP--packets with its destination field set
to \texttt{10.0.0.2}.

Each entry also has an associated set of \textit{actions}.  These dictates
what should happen when we have a match.  In the example above, the switch
may already know that \texttt{10.0.0.2} can be reached through port 5, and
so may proceed to \textit{forward} the packet there.

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline \textbf{Header fields} &
           \textbf{Counters} &
           \textbf{Actions} \\
    \hline \dots & \dots & \dots \\
  \end{tabular}

  \caption{The OpenFlow 1.0 flow table.}
  \label{openflow.flow.entry.spec}
\end{table}

If the packet matches no flow entries, it will by default send the packet up
to the controller, letting it decide what to do with it.  This commonly
happens right after starting up an OpenFlow switch, as its flow table will
be empty.

During this phase, the controller usually gets a lot of packets from the
switch.  The controller may then decide to \textit{install} new flow entries
in the switch, so that it can operate mostly by itself.  This is also good
for performance, allowing the switch to potentially operate at linespeed.

The flow table entries also have associated counters, used to count number
of packets handled, and so on.  It also has two timeout counters.  One of
them is the \textit{idle time} counter, and resets every time there is a
match.  The controller selects this value when it installs the entry, and it
will count backwards.  If it reaches zero, the entry will be removed from
the table.

There is also a \textit{hard timeout} counter.  This never resets, and is
there to keep the flow table from getting full.  For forwarding entries, one
can, for instance, set the idle timeout to 10 seconds and the hard timeout
to 60 seconds.  This means that after 1 minute, at the latest, the switch
will remove the entry.  If a new packet arrives after this, and there is no
other match in the table, then the controller will get the packet again and
can reinstall the same entry.

As you can see, OpenFlow allows one to construct L2 learning hubs and even
routers---or you can create entirely new forwarding mechanisms.

OpenFlow has been used for many purposes.  E.g., at Stanford, they installed
an OpenFlow system that was able to migrate a video game server \ac{VM} from
California to Japan---while it was running, without interruption, using the
\textit{same} IP--address \cite{erickson2008demonstration}
\cite{kobayashi2013maturing}.
The campus network on Stanford in fact uses a lot of OpenFlow devices.
Google also uses it in production in their global network.

\section{Forth}

\textit{Forth} is a concatenative, stack--based programming language.
Originally invented by Charles Moore in the 1970s for use with
microcontrollers, it still sees use today and has commonly been called a
trade secret for modern hardware vendors.

\todo{Explain threaded code, illustrate. It's an important concept and
explains why bytecode is to terse.}

The reason for its use is that it lets one run interpreted code on very
restricted systems. A Forth interpreter can be extremely small\footnote{For
instance, the \textit{Ngaro \ac{VM}} comes with a feature--complete
implementation of Forth and is written in only 778 lines of C code
\cite{ngaro.vm.core}.  The J1 Forth FPGA CPU core is less than 200 lines of verilog
\cite{bowman2010j1} and the core of the AmForth \textit{interpreter} for
ATmega CPUs is a mere 243 lines of assembly code, requires 8 kb flash
memory, 80 bytes EEPROM and 200 bytes RAM for the core system
\cite{amforth}.}, require little memory and have a quite small
interpretation overhead.

Forth is usually interpreted, and most instructions are function calls.
Data lives on a stack, and \textit{words} (functions in Forth) operate on them.
You also use this stack to pass parameters to words.

For the interpreter to be able to return from a word to where it was before,
it needs a second \textit{return--stack} to hold instruction pointers.

There is almost no syntax in Forth.  It uses \ac{RPN}, so programs tends to
be succinct and compact.  Comments are written in \texttt{( parenthesis)},
and it is common practice to write which parameters are expected on the
stack and which will be there after execution---separated by \texttt{--}.

To calculate $2 + (3 * 4)$, you write either of

\begin{figure}[H]
  \centering
  \begin{Verbatim}
  \ Alternative 1 (this is a comment)
  2 3 4 * +

  \ Alternative 2
  3 4 * 2 +
  \end{Verbatim}
\end{figure}

The interpreter works from left to right, top to bottom. It pushes values on
the data stack and performs operations when seeing
\textit{words} (\textit{commands} or \textit{procedures}).  In the first
alternative above, it will push 2, 3 and 4 on the stack.
  It then sees the multiply word \texttt{*}, which pops the
numbers 4 and then 3 from the stack, multiplies them and pushes the result
12 on the stack.  Next, it sees the \texttt{+} word,
pops off 12 and 2, adds them up and pushes the result 14 on the stack.

Alternative two is equivalent, but has a different order of operations.

To define a new word, you write

\begin{figure}[H]
  \centering
  \begin{Verbatim}
  : square ( n -- n^2 )
      dup * ;
  \end{Verbatim}
\end{figure}

The colon introduces a new word, followed by a name and all the instructions
up to the concluding semicolon.  Here you can see the comments in action,
showing how the \texttt{square} word expects a number on the stack
(\texttt{n}) and will replace it with its square.

The \texttt{dup} word will duplicate the item on the \ac{TOS}.  We
say \textit{item} here, because Forth lets you push different type of data
on the stack.\todo{I think this is wrong; it only allows numbers, so even
  strings push the address and length on the stack as numbers.}

To test this word, one can write 

\begin{figure}[H]
  \centering
  \begin{Verbatim}
  12 square .
  \end{Verbatim}
\end{figure}

which pushes 12 on the stack, replaces the number with its square
\texttt{144} and then the dot will take the number on the \ac{TOS}
and print it.

Because of the \ac{RPN}, some bits of code seem to be in reverse.  This is
very obvious for if--statements, which are terminated by the word
\texttt{THEN}.  So to test if two numbers are equal, we first need to push
two numbers on the stack, then perform some kind of comparison (for
instance, \texttt{=} for equality--testing) and then invoke the
\texttt{IF} word.  \texttt{IF} will take the number on the \ac{TOS}
and execute code conditionally, based on this number.  Most Forths use all
bits set to zero for the value \textit{false} and all bits set to one as
\textit{true}.  Usually, a \textit{true}--value is written using $-1$,
which has all bits set to one for systems that implement signed numbers
using two's complement.

Here is an example that prints strings based on the result of comparing two
numbers:

\begin{figure}[H]
  \centering
  \begin{Verbatim}
  : example
      10 20
      > if
          ." 10 is bigger than 20 " cr
        else
          ." 10 is not bigger than 20 " cr
        then ;
  \end{Verbatim}
\end{figure}

The \texttt{IF}--statements are only allowed in places where they are
\textit{compilable} in Forth. This is because Forth usually implements
if--then--else as \textit{compare--and--jump} in assembly, and therefore
needs to be able to precalculate addresses.  Practically speaking, it only
means that you cannot use if--statements in interactive sessions outside of
functions.  Also, most Forths are case--insensitive when it comes to
words, so we could either write \texttt{IF} or \texttt{if}.

The code above is equivalent to

\begin{figure}[H]
  \centering
  \begin{Verbatim}
  void example()
  {
    if ( 10 > 20 )
      printf("10 is bigger than 20\n");
    else
      printf("10 is not bigger than 20\n");
  }
  \end{Verbatim}
\end{figure}

in C.  Because parameters are passed on the stack, Forth programs tend to be
quite compact---and source code may look quite cryptic.  Because of this, it
is very important to write good word definitions.  Most words are very
short, often only a few lines.  The process of extracting small word
definitions from a source code is colloquially called \textit{factoring} in
Forth parlance.

\section{OpenVSwitch}

\section{Paxos}
Paxos is a distributed consensus algorithm.
\todo{Expand introduction and details}.

Even though the basic Paxos algorithm in \cite{Lam01} is quite simple, it can be
a challenge to implement properly \cite{Chandra:2007:PML:1281100.1281103}.
