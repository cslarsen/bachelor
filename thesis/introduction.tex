\chapter{Introduction --- new}

\todo{see}
- introduce by explaining that one has a NEED for our system and that it is
IMPORTANT:

- introduce what our thesis is about


\chapter{Introduction --- temporary}

With the advent of software-defined networking, the switch becomes a much
more central component in the network infrastructure.
%
That is, the switch can be programmed to perform a mude wider range of
functions that previously could not be done, or had to be done on end-hosts
or in the router.
%
This includes support for packet filtering (firewall), intrusion detection
and much more.

\todo{paragraph om sdn or similar to current version about origin but also
  include a little more about the controller, control plane, and forwarding
    plane.
    programmability of switches, open flow}

Another trend in the computing industry is that more and more services are
being moved to the cloud, reaching a larger number of users.
%
Thus, it becomes even more important that these services remain available
despite failure of individual machines running those services.
%
This calls for replicating these services on several machines.
%
A huge body of research in the distributed computing community has been
devoted to coming up with protocols to guarantee strong consistency among
the replicas of such a service.
%
THe most cited of these protocols is the Paxos protocol \cite{Lam01}.
%
\todo{More on paxos. most general purpose implementations of paxos are
  implemented as middleware frameworks at the end-host level.}

In this thesis we want to answer the following question: \textit{Can we
implement the Paxos protocol at the switch level?}
%
You may ask what are the benefits of doing this?
%
There are several reasons that we will return to later in this thesis, but
we list the three most important here:

\begin{itemize}
  \item \textbf{Transparency:} We guarantee consistent in-order delivere of
  network packets at all replicas.  This has the benefit that network
  applications can be replicated without the need for complicated Paxos
  logic. While this is usually handled by a middleware framework, we can
  avoid imposing a specific API on the application developer.  For example,
  frameworks typically impose a language specific API, preventing users of
  other languages from leveragint the replication service. (We ignore the
      need for state transfer in this thesis.)

  \item \textbf{Performance:} By implementing Paxos in the switch, we
  expect to see a performance improvement. This is because, assuming the
  latency between the switches is low, we can avoid the extra messages and
  latency of traversing the links and IP stack of the end-hosts running the
  replicas of the services.

  \item \textbf{Cross-application}: \todo{Find a better name}
  Using a setup with Paxified switches, every application that wishes to
  have their messages totally ordered, can use that functionality of the
  switches. Thus, we can leverage one setup to provide several replicated
  services with ordered message delivery. Therefore, instead of having each
  replicated service runing its own Paxos protocol, they can all receive
  ordered messages from the switches. While this still requires that Paxos
  messages be exchanged between switches, it can reduce the traffic on the
  links between the switches and replicas.

\end{itemize}

Further, it is also reasonable to ask, what are the drawbacks of
implementing Paxos in the switch? There are a few drawbacks and restrictions
worth mentioning.

The performance improvement we expect to see is fairly small compared to
wide-area network latencies.  Thus, it may not make sense to place Paxos
logic in the switches that communicate over wide-area links. That said,
there are several works in which one runs two separate Paxos
protocols, one within each data center, and another between data
centers \cite{zorfu, steward, cft}.
In such a configuration, it would definitely make sense to use in-switch
Paxos deployments within the data center, even though the other Paxos does
not.

While most of the time a single switch operates as an autonomous unit, to
implement Paxos in the switch, we need to impose some restrictions on the
topology between the machines.

A drawback with implementing Paxos in the siwtch is that a physical switch
typically has a very restricted instruction set available, and thus
implementing Paxos at this low-level can be very challenging and prone to
unforeseen issues.

Despite these restrictions, we believe that the benefits can be of value to
a wide range of deployments where it is desirable to provision enough
replication to ensure high availability of services.

\chapter{Introduction --- old}

\todo{Gammel introduksjon følger}

Around 2008, \textbf{\acf{SDN}}\index{software-defined networking}
\cite{Casado:2005:VNS:1047344.1047383} emerged from research at
Berkeley\index{Berkeley} and
Stanford\index{Stanford} as a way to enable networks to be defined and managed using
software. One model of \acs{SDN} is \textit{OpenFlow}\todo{Cite!}, which
decouples the control plane\index{control plane} from the forwarding
plane\index{forwarding plane}\index{data plane|see{forwarding plane}} in a
switch, moving it out of the physical switch to an external controller node.
It enables one to implement the controller in software.

Although invented quite recently, software-defined networking is already
being heavily used both in academia and industry.  Google\index{Google}, for instance, are
using OpenFlow to ease deployment and increase utilization in their backbone
networks\index{backbone network} \cite{crabbe2012sdn} and Stanford has deployed several
OpenFlow-controlled networks on their university network.

In March 2013, IDC\index{IDC} \todo{finn ut hva det står for} projected that the SDN market would
  reach \${}3.7 billion by 2016, capturing a 35\%{} share of the switching
  market \cite{Kirkpatrick:2013:SN:2500468.2500473}.
\todo{Skriv om denne setningen, den er tatt nesten direkte fra artikkelen!}

OpenFlow is detailed in \vref{chapter:background.openflow}.

\textbf{Paxos}\index{Paxos} \cite{Lamport:1998:PP:279227.279229} is a
family of distributed, fault-tolerant consensus algorithms.  It allows
network nodes to reach \textit{agreement} even in the face of intermittent
network failures.  For example, one can design a database system using Paxos
to make sure that transactions are executed in the same order on all nodes.

Originally published by Leslie Lamport\index{Lamport, Leslie} in 1989, Paxos
has spawned numerous extensions, including cheap Paxos,
\index{cheap Paxos}\index{Paxos!cheap Paxos} fast Paxos
\index{fast Paxos}\index{Paxos!fast Paxos} and Byzantine
\index{Paxos!Byzantine Paxos}\index{Byzantine Paxos}, fault-tolerant variants.

It is discussed in \vref{chapter:background.paxos}.

Our aim is to implement Paxos phase two on the switch and its controllers,
so that client packets can be ordered and sent to all services.
%
Paxos will be implemented on OpenFlow switches to guarantee that
packets sent to all of their connected nodes are sent in the same order.
These end-hosts can run any networking service and leverage the benefits of
Paxos without needing to handle any details of the algorithm.

\section{Hypothesis}

For simplicity, we will constrain our scope to a few primitives of
classic crash Paxos\index{Paxos!classic crash} in \textit{phase two},
where we have steady-state
flow\index{Paxos!steady-state flow} with no failures\index{Paxos!failure}.

Furthermore, we want to look at opportunities for increasing networking
performance by moving parts of the Paxos from the control
plane\index{control plane} down to the switches' forwarding
plane\index{forwarding plane}.

We will implement this in progressive stages:

\begin{enumerate}
  \item Implement Paxos entirely in controllers connected to an OpenFlow
  switch.

  \item Extend OpenFlow and Open vSwitch so we can execute Paxos in the
  forwarding plane of the switch.

  \item Move parts of the Paxos implementation down to the forwarding plane
  (OpenFlow \textit{flow tables}), achieving a good balance of performance and
  programming maintainability
\end{enumerate}

Our hypothesis is two-fold:

\begin{enumerate}
\item Network nodes can leverage Paxos guarantees \textit{transparently} by
implementing it on the software switches using OpenFlow.
\item We can achieve good relative performance by moving parts of the
implementation from the OpenFlow controllers down to the software switches.
\end{enumerate}

We aim to build a proof-of-concept system backing up these claims.  The
thesis will therefore be a study of \textit{feasibility}.

\section{Overview}

\todo{Flytt dette inn i teksten over, trenger ikke være egen section.}
We discuss the theoretical background needed to understand this thesis in
chapter \ref{chapter:background} \vpageref{chapter:background}.  If you already know \acs{SDN},
OpenFlow and Paxos, you can skip this chapter.

Then we look at what OpenFlow can offer us in chapter
\ref{chapter:details.openflow}
\vpageref{chapter:details.openflow}, detail what Paxos requires for
implementation in chapter \ref{chapter:details.simplified.paxos} 
\vpageref{chapter:details.simplified.paxos} and propose a
design based on this in chapter \ref{chapter:design} \vpageref{chapter:design}.
\todo{Sjekk at linker stemmer, kan gjerne forenkles også + forbedres}

Finally, we .... blabla ... look at benchmarks and conclude in chapter
\ref{chapter:conclusion} \vpageref{chapter:conclusion}.

\section{Scope}

\todo{Fra Hein, skriv om.}
The objective in this thesis is to explore the feasability of implementing a
distributed protocol in the switch.  It is specifically not a goal to
implement a full Paxos implementation that captures all the possible corner
cases of Paxos to tolerate failures.
%

% Også fra Hein
While Paxos is specifically about fault-tolerance, we are only intereste in
understanding the capabilities and feasability of implementing Paxos in the
switch.

We will only look at a simplified version of Paxos in which we only
implement accept and learn messages. We ignore liveness checking such as
heartbeats. We ignore implementing the expanded OpenFlow features in the
network protocol and controller. We only look at steady state Paxos.
We assume switches are co-located. etc etc etc.

We also ignore the fact that if a switch goes down and back up again, it
will need to rejoin the Paxos network and its end-hosts need to synchronize
state\index{synchronization} (or just copy the state from a host on another switch).

