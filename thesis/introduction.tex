\chapter{Introduction}

\section{Software defined networking}

\acf{SDN} \cite{Casado:2005:VNS:1047344.1047383} emerged from research at
Berkeley and Stanford around 2008 as a way to enable networks to be defined
and managed using software.

Central to the idea was to split the {\em control} and {\em data} planes.
While routers traditionally contained both, one would now extract the
controller and move it out to an external device --- e.g.~as a software
component, running on a server.  They would then communicate over a network
channel, using a predetermined protocol.

{\em One} such protocol is {\em OpenFlow}\index{OpenFlow}\footnote{Other
\ac{SDN} solutions predating OpenFlow are SANE
\cite{Casado:2006:SPA:1267336.1267346}, Ethane
\cite{Casado:2007:ETC:1282427.1282382}, 4D
\cite{Greenberg:2005:CSA:1096536.1096541}, etc.}
\cite{McKeown:2008:OEI:1355734.1355746}.  It allows the two planes to
interact using a predetermined set of commands.  The controller configures
so--called {\em flow tables}\index{flow table} in the data plane \index{data
plane} which contain matching patterns and actions for incoming packets.
These tables are designed for high--speed routing, and are thus quite
simple.  On the other hand, the controller can be arbitrarily complex.

To maintain high networking speeds, the interaction between the data and
control planes should be kept at a minimum.  The optimal case is when the
data plane is able to route packets entirely on its own.  In practice, the
control plane updates the flow tables, but does this as seldomly as
possible.

The data plane can also forward packets to the control plane\index{control
plane} for routing decisions. The extreme case is when {\em all} packets are
forwarded to the control plane.  While this allows very advanced behaviour
--- deep packet inspection, for instance --- it obviously comes at the cost
of lower networking performance.  Therefore, one must be diligent in
designing such a network.

Today, several \acp{SDN} have been deployed, powering production--critical
systems for global internet giants\footnote{Examples are
Google's\index{Google} {\em Chubby}\index{Chubby} distributed lock
service\index{lock server} and the {\em Megastore}\index{Megastore}
distributed, high--availability storage system.}.

\section{Paxos}

{\em Paxos}\index{Paxos} \cite{Lamport:1998:PP:279227.279229} is a family of
distributed, fault--tolerant consensus algorithms.  It allows network nodes
to reach {\em agreement} even in the face of intermittent network failures.
For example, one can design a database system using Paxos to make sure that
transactions are executed in the same order on all nodes.

Originally published by Leslie Lamport\index{Lamport, Leslie} in 1989, Paxos
has spawned numerous extensions like Byzantine tolerance and so on.

\section{A Paxos--enabled software defined network}

Our aim is to build an efficient, {\em Paxos--enabled software defined
network} where nodes are able to leverage the guarantees of Paxos without
needing to handle the details.

For simplicity, we will constrain our scope to Paxos {\em phase two} where
we have steady--state flow with no failures.

We will implement this in progressive stages:

\begin{itemize}
\item Stage 1: Implement Paxos entirely on the controller.
\item Stage 2: Move parts of Paxos down from the controllers to the
switches.
\item Stage 3: Look for possible expansion of the OpenFlow protocol to
facilitate running Paxos on the switches.
\end{itemize}

Stage 1 should be the easiest to implement, and will be used as a baseline
for comparing networking performance with later stages.

Additionally, we will implement Paxos entirely on the network nodes, using
the same topology, to get an idea of how much of a performance hit we take
for running it on the controller.

In stage 2, we will look at how we can improve efficiency by moving parts of
the algorithm down into the switches using the flow tables.

Finally, in stage 3 we will investigate whether it would make sense to
enhance the OpenFlow protocol with new primitives to build fast
networking services such as Paxos.

{\em 
  Our hypothesis is that by moving parts of the Paxos implementation down to
  the switches, we will get a more performant system than by running Paxos
  either on the controller or on the network nodes.
}

The thesis will therefore be a study of {\em feasibility}.
