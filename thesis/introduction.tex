\chapter{Introduction}

Around 2008, \textbf{\acf{SDN}}\index{software-defined networking}
\cite{Casado:2005:VNS:1047344.1047383} emerged from research at
Berkeley\index{Berkeley} and
Stanford\index{Stanford} as a way to enable networks to be defined and managed using
software. One model of \acs{SDN} is \textit{OpenFlow}\todo{Cite!}, which
decouples the control plane\index{control plane} from the forwarding
plane\index{forwarding plane}\index{data plane|see{forwarding plane}} in a
switch, moving it out of the physical switch to an external controller node.
It enables one to implement the controller in software.

Although invented quite recently, software-defined networking is already
being heavily used both in academia and industry.  Google\index{Google}, for instance, are
using OpenFlow to ease deployment and increase utilization in their backbone
networks\index{backbone network} \cite{crabbe2012sdn} and Stanford has deployed several
OpenFlow-controlled networks on their university network.

In March 2013, IDC\index{IDC} \todo{finn ut hva det står for} projected that the SDN market would
  reach \${}3.7 billion by 2016, capturing a 35\%{} share of the switching
  market \cite{Kirkpatrick:2013:SN:2500468.2500473}.
\todo{Skriv om denne setningen, den er tatt nesten direkte fra artikkelen!}

OpenFlow is detailed in \vref{chapter:background.openflow}.

\textbf{Paxos}\index{Paxos} \cite{Lamport:1998:PP:279227.279229} is a
family of distributed, fault-tolerant consensus algorithms.  It allows
network nodes to reach \textit{agreement} even in the face of intermittent
network failures.  For example, one can design a database system using Paxos
to make sure that transactions are executed in the same order on all nodes.

Originally published by Leslie Lamport\index{Lamport, Leslie} in 1989, Paxos
has spawned numerous extensions, including cheap Paxos,
\index{cheap Paxos}\index{Paxos!cheap Paxos} fast Paxos
\index{fast Paxos}\index{Paxos!fast Paxos} and Byzantine
\index{Paxos!Byzantine Paxos}\index{Byzantine Paxos}, fault-tolerant variants.

It is discussed in \vref{chapter:background.paxos}.

\textbf{Our aim} is to build an efficient, \textit{Paxos-enabled software defined
network}.  Paxos will be implemented on OpenFlow switches to guarantee that
packets sent to all of their connected nodes are sent in the same order.
These end-hosts can run any networking service and leverage the benefits of
Paxos without needing to handle any details of the algorithm.

\section{Hypothesis}

For simplicity, we will constrain our scope to a few primitives of
classic crash Paxos\index{Paxos!classic crash} in \textit{phase two},
where we have steady-state
flow\index{Paxos!steady-state flow} with no failures\index{Paxos!failure}.

Furthermore, we want to look at opportunities for increasing networking
performance by moving parts of the Paxos from the control
plane\index{control plane} down to the switches' forwarding
plane\index{forwarding plane}.

We will implement this in progressive stages:

\begin{enumerate}
  \item Implement Paxos entirely in controllers connected to an OpenFlow
  switch.

  \item Extend OpenFlow and Open vSwitch so we can execute Paxos in the
  forwarding plane of the switch.

  \item Move parts of the Paxos implementation down to the forwarding plane
  (OpenFlow \textit{flow tables}), achieving a good balance of performance and
  programming maintainability
\end{enumerate}

Our hypothesis is two-fold:

\begin{enumerate}
\item Network nodes can leverage Paxos guarantees \textit{transparently} by
implementing it on the software switches using OpenFlow.
\item We can achieve good relative performance by moving parts of the
implementation from the OpenFlow controllers down to the software switches.
\end{enumerate}

We aim to build a proof-of-concept system backing up these claims.  The
thesis will therefore be a study of \textit{feasibility}.

\section{Overview}

\todo{Flytt dette inn i teksten over, trenger ikke være egen section.}
We discuss the theoretical background needed to understand this thesis in
chapter \ref{chapter:background} \vpageref{chapter:background}.  If you already know \acs{SDN},
OpenFlow and Paxos, you can skip this chapter.

Then we look at what OpenFlow can offer us in chapter
\ref{chapter:details.openflow}
\vpageref{chapter:details.openflow}, detail what Paxos requires for
implementation in chapter \ref{chapter:details.simplified.paxos} 
\vpageref{chapter:details.simplified.paxos} and propose a
design based on this in chapter \ref{chapter:design} \vpageref{chapter:design}.
\todo{Sjekk at linker stemmer, kan gjerne forenkles også + forbedres}

Finally, we .... blabla ... look at benchmarks and conclude in chapter
\ref{chapter:conclusion} \vpageref{chapter:conclusion}.

\section{Scope}

\todo{Fra Hein, skriv om.}
The objective in this thesis is to explore the feasability of implementing a
distributed protocol in the switch.  It is specifically not a goal to
implement a full Paxos implementation that captures all the possible corner
cases of Paxos to tolerate failures.
%

% Også fra Hein
While Paxos is specifically about fault-tolerance, we are only intereste in
understanding the capabilities and feasability of implementing Paxos in the
switch.

We will only look at a simplified version of Paxos in which we only
implement accept and learn messages. We ignore liveness checking such as
heartbeats. We ignore implementing the expanded OpenFlow features in the
network protocol and controller. We only look at steady state Paxos.
We assume switches are co-located. etc etc etc.

We also ignore the fact that if a switch goes down and back up again, it
will need to rejoin the Paxos network and its end-hosts need to synchronize
state\index{synchronization} (or just copy the state from a host on another switch).

