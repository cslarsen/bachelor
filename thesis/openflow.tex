\chapter{OpenFlow}
\include{openflow-versions}

\section{Extending OpenFlow}

Based on our previous discussions on OpenFlow functionality and our
simplified Paxos algorithm, we now present some new primitives for OpenFlow
that can be used to implement \texttt{ACCEPT} and \texttt{LEARN} messages.

\subsection{Data table}

First we need to be able to store the round number (\texttt{rnd}) and a
packet ID (\texttt{vval}).

We propose that the switch adds a new table that can be used to store
values.  To conserve memory, we will allow 256 entries in the table, each
with a field of 32 bits, totalling a mere 1024 bytes.

The table is meant to be used by the switch itself and not by the
controller, but one could propose store and retrieve operations for the
controller.  These are, however, not needed for our purposes.

There should only be need for one table per switch.  This is in contrast to
the OpenFlow counters, which are per flow table, per flow entry and so on.

\subsection{Table read and write actions}

The switch will need to be able to read and write to the data table.
These will be available as actions in the flow table entries.

At the very least, we will need actions to perform the following operations.

\todo{Would it be better with a Forth--like language and a small stack VM
  instead?}

\begin{table}[H]
  \begin{tabular}{|l|l|l|}
    \hline \textbf{Name} & \textbf{Parameters} & \textbf{Description} \\
    \hline GET & 8--bit table offset & Returns value from table \\
    \hline SET & 8--bit table offset and 32--bit value & Sets value in table \\
    \hline INC & 8--bit table offset & Increments value at given table location \\
    \hline CMP & ... & ... \\
    \hline
  \end{tabular}
  \caption{Data table operations}
  \label{extended.openflow.operations}
\end{table}

\begin{verbatim}
What we need is actually:

- to MATCH a given packet that contains special data, e.g. (ACCEPT, n, v),
  and match only "IF TABLE[0] >= n"
- A resulting action would then be to "SET TABLE[0], n" and then "FLOOD
  (LEARN, n, v)" to the group "switches".
- If we're to send the packets immediately to the end--systems, we need to
  be able to FRAGMENT packets, store some IDs and then send the remaining
  fragment.  For simplicity, perhaps I should wait with this part?
- I think we should look at the complete Paxos algorithm and see what would
  be needed to implement everything.
- Note also how the table ops almost look like registers
- Also note how we are almost creating a Turing complete system. That's what
  we want to avoid, but for generality, the is probably what is required.
\end{verbatim}

\subsection{New matching patterns}
