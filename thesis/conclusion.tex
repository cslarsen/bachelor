\chapter{Conclusion}
\label{chapter:conclusion}

We set out to explore the merits of moving Paxos to the switch-level.

\section{Paxos in the Controller}

In doing so, we implemented Paxos on a software controller, sending commands
to a switch.  Using this, we designed a distributed, replicated system with
guaranteed ordering for the UDP protocol.  The switches sent all packets up
to the controller, who then performed Paxos ordering before delivering
duplicated packets to end-hosts.

The main findings for this part of the thesis are:

\begin{itemize}
  \item Providing Paxos ordering transparently is possible, as we have
  demonstrated, and we were able to provide ordering of \acs{UDP} packets on
  a network consisting of three switches and nine end-hosts.

  Especially for UDP-based services, being able to guarantee same-sequence
  replication may be useful for certain types of services.

  \item We were unable to perform reliable replication of \acs{TCP}-packets,
  as we did not consolidate replies back to the server.  While each end-host
  received the same \acs{TCP} packets in the same order, there were
  different network path lengths, and the host that were closer to the
  client replied first, causing a \textit{race-condition} where the client
  received its reply and send back a TCP FIN packet, ending the session on
  the other hosts.

  The TCP protocol's design runs contrary to the way we attempted to perform
  replication:  It has an ordering scheme of its own, and seeks to establish
  an end-to-end connection.

  \item There was a big overhead in sending full packets to the controller
  and not use the flow tables for fast switching.  This was expected, and
  the \acs{RTT} was between $2$ and $5$ times larger than ICMP ping RTT
  using flows, and between

  This result is not surprising, though, as packets need to perform
  additional link-hops to get from the switch to the controller and down
  again.

\end{itemize}

\section{The Paxos non-IP Network Protocol}

We designed a simple, non-IP protocol for exchanging Paxos-messages, putting
the parameters in the payload of Ethernet frames.  By definition, this is a
separate, non-IP protocol.

While the protocol was very simple, not accounting for retransmission,
data corruption and the like, it was demonstrated to work reliably on the
software simulator.

Furthermore, being so simple, it was very easy to reuse it when moving from
the Paxos controller down to Paxos in Open vSwitch.  Extracting Paxos
parameters was simply a matter of looking at given offsets in the packet
data.

\section{Paxos in the Switch}

We partially implemented Paxos on the switch itself by modifying the Open
vSwitch source code.  Due to complexities in the architecture of such an
advanced, production-grade software system, we were unable to fully test it.

While we implemented all parts of the simplified, multi-Paxos algorithm,
including handling of incoming client packets, accept and learn
messages, we were not able to send out stored packets on the network.
The sole reason was lack of time: This is complex software to understand,
and sometimes its architecture prevented us from making progress.

On the other hand, we were able to easily program flows using Paxos as
constituent primitives, and could combine them with existing OpenFlow
actions.  We believe this shows that programming not only the controller,
but new actions on the \textit{switch}Â as well can be very useful and even
make it easier to build complex networking flows.
